//这只是一个随手的foolish solution，yangwuqi
//4ms，faster than 100%

func divide(dividend int, divisor int) int {//先把数都变成非负数方便操作，然后使用每次2倍的方法去重复试探，试探超过时，倍数除以2，记录下已有倍数，把不够的部分重新试探
     var flag int
     var pos int
    if dividend<=0&&divisor>0{
        pos=-1
        dividend=-dividend
    }else if dividend<=0&&divisor<0{
        pos=1
        dividend=-dividend
        divisor=-divisor
    }else if dividend>0&&divisor>0{
        pos=1
    }else if dividend>0&&divisor<0{
        pos=-1
        divisor=-divisor
    }
    flag=find(dividend,divisor)
    max:=pow(2,31)-1
    min:=pow(2,31)
    if flag>max&&pos==1{
        return max
    }else if flag>min&&pos==-1{
        return -min
    }
    return flag*pos
}
func find(dividend int, divisor int)int{
    if dividend<divisor{
        return 0
    }
    sum:=divisor
    var freq int
    var flag int
    for sum<=dividend{
        sum=divisor*pow(2,freq)
        if sum>dividend{
            break
        }
        freq++
    }
    if freq>0{
    flag=pow(2,freq-1)
    }
    if dividend-sum/2!=0{
        sum=dividend-sum/2
        return flag+find(sum,divisor)
    }
    return flag 
}
func pow(n int, freq int)int{
    c:=1
    for i:=0;i<freq;i++{
        c=c*n
    }
    return c
}
